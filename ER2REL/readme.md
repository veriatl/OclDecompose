Example of fault-localzation approach by decomposition: the ER2REL Transformation
=======

Metamodel
------
![alt tag](https://github.com/veriatl/OclDecompose/blob/master/ER2REL/Src/er.png)


Transformation
------
[url](https://github.com/veriatl/OclDecompose/tree/master/ER2REL/Src/er2rel.atl)

Full Contract
------
[url](https://github.com/veriatl/OclDecompose/tree/master/ER2REL/Src/contract.atl)

Postcondition
------
0/ The original postcondition:
```
context REL!RELSchema inv Post1: 
REL!RELSchema.allInstances()->forAll(s | 
  s.relations->forAll(r1 | 
    s.relations->forAll(r2 | r1<>r2 implies r1.name<>r2.name)))
```

1/ The first step is to extract static trace information via static analysis of the input ATL transformation. The static trace information is automatically built by examining the output element types of each ATL rule, i.e. the \emph{to} section of the rule. Thus, we have:
```
[
REL!RELSchema: {S2S},
REL!Relation: {E2R, R2R},
REL!RELAttribute: {EA2A, RA2A, RA2AK}
]
```

2/ The decomposition of the OCL postcondition is performed by two consecutive algorithms. In the expand algorithm, we examine the input OCL postconditon, and identify all its sub-expressions that have a static type in the target metamodel. Then we expand each of these expressions into an equivalent form decorated with the trace information. Therefore, our postcondition after expand becomes:
```
context REL!RELSchema inv Post1_expand: 
union_select(REL!RELSchema.allInstances(), [S2S])->forAll(s | 
  union_select(s.relations, [E2R,R2R])->forAll(r1 | 
    union_select(s.relations, [E2R,R2R])->forAll(r2 | 
      r1<>r2 implies r1.name<>r2.name)))
```

3/ In the enumerate algorithm, we traverse the abstract syntax tree of the expanded OCL postcondition to identify nodes with trace information. Then, depending on the context of these nodes, our algorithm systematically enumerates the original OCL postcondition into OCL sub-goals. Proving these generated OCL sub-goals implies the correctness of the original OCL postcondition. Our expanded postcondition now becomes:
```
context REL!RELSchema inv S1: 
REL!RELSchema.allInstances()->forAll(s | genBy(s, S2S) implies 
  s.relations->forAll(r1 | genBy(r1, E2R) implies
    s.relations->forAll(r2 | genBy(r2, E2R) implies
      r1<>r2 implies r1.name<>r2.name ) ) )

context REL!RELSchema inv S2: 
REL!RELSchema.allInstances()->forAll(s | genBy(s, S2S) implies 
  s.relations->forAll(r1 | genBy(r1, E2R) implies
    s.relations->forAll(r2 | genBy(r2, R2R) implies
      r1<>r2 implies r1.name<>r2.name ) ) )
	  
context REL!RELSchema inv S3: 
REL!RELSchema.allInstances()->forAll(s | genBy(s, S2S) implies 
  s.relations->forAll(r1 | genBy(r1, R2R) implies
    s.relations->forAll(r2 | genBy(r2, E2R) implies
      r1<>r2 implies r1.name<>r2.name ) ) )

context REL!RELSchema inv S4: 
REL!RELSchema.allInstances()->forAll(s | genBy(s, S2S) implies 
  s.relations->forAll(r1 | genBy(r1, R2R) implies
    s.relations->forAll(r2 | genBy(r2, R2R) implies
      r1<>r2 implies r1.name<>r2.name ) ) )
```

4/ Eventually, 4 sub-goals are generated by applying our enumerate algorithm, and their dependency are recorded through the prove options and the intermediate results as in a proof tree: 

![alt tag](https://github.com/veriatl/OclDecompose/blob/master/ER2REL/Src/tree.png)